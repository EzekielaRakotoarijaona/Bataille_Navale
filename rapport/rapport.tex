\documentclass{article}
\usepackage{graphicx}
\usepackage[french]{babel}
\title{Rapport projet de r\'eseau}
\author{DELAR Emmanoe, RAKOTOARIJAONA Camille}
\begin{document}
\maketitle
\newpage
\tableofcontents

\newpage
\section{Introduction}
Lors de ce projet, r\'ealis\'e en bin\^omes, nous avions pour objectif de d\'evelopper un jeu de bataille navale en r\'eseau. Pour cela, nous avons utilis\'e le language de programmation objet Python.
On est parti du code source fourni par notre enseignant. Ce code nous permettait de jouer contre la machine uniquement. D\`es lors, nous avons d\^u l'am\'eliorer afin de pouvoir jouer \`a 1 contre 1 sur le r\'eseau.  

\section{Fonctionnement du jeu}
	 \subsection{Pr\'esentation du jeu}
	 La bataille navale est un jeu de soci\'et\'e dans lequel deux joueurs doivent placer des « navires » sur une grille tenue secrète et tenter de « toucher » les navires adverses. Le gagnant est celui qui parvient \`a torpiller compl\`etement les navires de l'adversaire avant que tous les siens ne le soient.

	 \subsection{Jouer contre la machine}
	 Lorsqu'on lance le programme avec le nom du serveur en argument, si on choisi de ne pas jouer en r\'eseau alors le jeu commence directement. On choisi la colonne et la ligne de la grille de l'ordinateur \`a viser. Quand c'est au tour de l'ordinateur, une fonction fait de m\^eme, choisie des coordonn\'ees al\'eatoirement puis joue son coup. Et ainsi de suite jusqu'\`a la fin de la partie. 

	 \subsection{Jouer en r\'eseau local}
	 Si on choisi de jouer en r\'eseau, comme demand\'e dans le sujet du projet, il faut d’un c\^ot\'e, d\'emarrer le serveur en lan\c cant le programme \guillemotleft main.py\guillemotright \ sans arguments, et du c\^ot\'e client, il faut lancer le programme avec l’adresse ip du serveur en argument.
	 \newline Lorsque ceux-ci sont lanc\'es, le client aura la possibilit\'e de choisir d’abord si il veut se connecter au serveur, ou si il veut jouer seul face au robot comme d\'ecrit au dessus. 
	 \newline Si il d\'ecide de jouer en r\'eseau contre quelqu\textquoteright un, le programme attendra qu\textquoteright une deuxième personne se connecte au serveur pour jouer aussi, et ainsi ils pourront jouer tous les deux. 
	 \newline Ensuite, chacun jouera \`a tour de r\^ole jusqu\textquoteright a ce que la partie soit termin\'ee, lorsque la partie est termin\'ee chaque joueur verra le score, et le serveur se d\'econnectera et le jeu de chaque joueur aussi. 
	 \newline Il est \`a noter que les joueurs peuvent donc jouer tout seul peu importe le moment sans affecter le serveur lorsqu\`\ ils jouent en local.

\section{Structure du code}
	\subsection{Serveur}
	Contrairement \`a la partie contre l'ordinateur, en mode r\'eseau, les coordonn\'ees choisies par le client sont envoy\'es au serveur qui les retransmet au deuxi\`eme joueur connect\'e.
	\`A l'aide du constructeur socket, nous avons alors cr\'e\'e un serveur de famille ipv6 en connexion TCP.
	Nous l'avons rattach\'e au port 7777 ( choisi arbitrairement ) puis nous avons lanc\'e notre serveur en mode \'ecoute.
	parler du numero de port.
	\newline
	\newline La partie serveur est un peu complexe car il joue le rôle de lien entre les joueurs. 
	Au lancement de celui-ci, nous nous trouvons dans la fonction main principale, tout cela par la méthode
	select apprise en cours. 
	Lorsque 2 joueurs sont enfin connectés, le serveurs envoie aux deux joueurs un numéro, 0 ou 1, en fonction de celui qui s’est connecté en premier à l’aide de la méthode « socket.send » qui défini le joueur qui jouera en premier et celui qui jouera en deuxième. 
	La deuxième étape, est la partie la plus complexe et celle qui nous a posé le plus de problèmes car c’est celle qui consiste à envoyer le jeu qui a été crée par le serveur.
	En effet nous avons fait le choix de de faire créer un jeu aléatoire par le serveur dans ce cas-ci et de l’envoyer aux deux joueurs, ainsi ,implémenter l’extension pour pouvoir avoir des spectateurs est plus simple car, nous avons modifié le code principal et on peut donc envoyer le jeu à d’autres joueurs aussi, ce qui peut permettre à des spectateurs de voir le jeu se dérouler.
	La fonction qui a été modifié est, la fonction « randomConfiguration » qui créer la table de bateaux aléatoirement.
	Tout d’abord dans la fonction tout se passe normalement comme dans la fonction précédente, cependant, à chaque fois que l’on a stocké une coordonnée et une position de bateau, on les mets dans un tableau, ensuite, on envoie le tout aux deux joueurs à travers une boucle parcourant le tableau.
	Cette partie nous a posé plusieurs problèmes, nous avons par exemple eu un problèmes au niveau de la taille des bateaux car les valeurs devaient être envoyées en  bytes et avaient des tailles variables, de 1 à 2 bytes car on avait des valeurs de 1 à 10 et 10 était représenté sur 2 bytes, on a donc décidé de retire 1 à chaque valeur pour être sur 0 à 9 et ainsi avoir une taille au maximum de 1 byte et chaque valeurs, reçue de l’autre côté par les joueurs serait incrémentée de un, tout cela fait pour l’envoie des navires. 
	Le deuxième problème était aussi un peu complexe, mais après débogage, on a pu voir que l’on envoyait avant directement chaque valeur aléatoire sans avoir au préalablement vérifié si on avait une configuration valide à travers la fonction « isValidConfiguration ».
	On a alors compris qu’il fallait prendre les dernières valeurs de configuration valide et envoyer le tout à chaque joueurs après.
	Et enfin comme la fonction basique, celle-ci retourne un bateau. On répète alors ceci 2 fois et pour avoir la table de jeu.
	Ensuite, c’est le début de la partie, la boucle qui fait jouer le serveur est la même que celle qui fait jouer le robot ou chaque joueur, cependant, celui-ci se place d’abord dans la partie du premier joueur de la boucle, et attendra que le joueur envoie son coup, il mettra le coup sur sa table de jeu et  l’enverra à l’autre joueur, tout cela avec la méthode recv et send. Et passera ensuite à la partie du joueurs 2 de la boucle et fera de même. Et ainsi de suite jusqu’à ce que le jeu soit fini. Ensuite il sort de la boucle et ferme les socket et la fonction et le serveur.

	\subsection{Connexion client}
	Pour que le client se connecte au serveur, il nous faut le nom de l'h\^ote et le num\'ero de port.
	\newline Ensuite, on va cr\'e\'e une socket (client) compatible ipv6 qui va nous permettre d'ouvrir une connexion avec une machine locale et d'\'echanger des informations (\`a l'aide de la m\'ethode "bind").
	\newline Pour r\'ecuperer les premieres informations, notamment le num\'ero du joueur, les navires, on intercepte les premiers bytes envoyés par la socket serveur (\`a l'aide de la m\'ethode "client.recv")
	\newline Avec de ces informations on g\'en\'ere une partie \`a partir d'une fonction Game
	\newline Une fois la partie lanc\'ee, si c'est au joeur actuel de jouer, il entre les coordonn\'ees \`a viser. Ensuite, on va envoyer ces coordonn\'ees (x,y) au serveur. Le serveur va retransmettre ces informations sous forme de byte \'a l'autre joueur (\`a l'aide de la m\'ethode "client.send").
	\newline Par contre si c'est au tour de l'autre joueur, la socket client se met en mode r\'eception et attend les coordonn\'ees choisies par l'adversaire (\`a l'aide de la m\'ethode "client.recv"). Ces donn\'ees sont envoy\'ees par le serveur. 
	\newline Ce protocole est r\'ep\'et\'e jusqu'\`a la fin de la partie.

	\subsection{Protocole de communication}
	Une fois la connexion \'etablie, la communication serveur/client est tr\`es simple.
	Chaque information n\'ecessaire \`a l'initialisation d'une partie est envoy\'e par le serveur bit \`a bit et ainsi r\'ecup\'er\'e du c\^ot\'e client.
	Il faut noter la n\'ecessit\'e \`a convertir les bytes recus en entier (int).

\section{Extensions}

\section{Conclusion}

\end{document}